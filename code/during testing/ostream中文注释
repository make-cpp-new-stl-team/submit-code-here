// Output streams -*- C++ -*-

// Copyright (C) 1997-2020 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/ostream
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.6.2  Output streams
//
// Output streams -*- C++ -*-
// 这是GNU ISO C++库的输出流实现文件

// Copyright (C) 1997-2020 Free Software Foundation, Inc.
//
// 这是GNU ISO C++库的一部分。该库是自由软件，
// 你可以在GNU通用公共许可证的条款下重新分发和/或修改它。

// 该库分发时不提供任何担保，甚至不保证适销性或特定用途的适用性。
// 更多细节请参见GNU通用公共许可证。

/** @file include/ostream
 *  这是C++标准库的头文件
 *  实现了输出流相关的功能
 */

// ISO C++ 14882: 27.6.2 输出流

#ifndef _GLIBCXX_OSTREAM
#define _GLIBCXX_OSTREAM 1

#pragma GCC system_header

#include <ios>
#include <bits/ostream_insert.h>

namespace std _GLIBCXX_VISIBILITY(default) {
    _GLIBCXX_BEGIN_NAMESPACE_VERSION

    /**
     * @brief 输出流的基类模板
     * @tparam _CharT 字符类型
     * @tparam _Traits 字符特征类型
     *
     * 这是所有输出流的基类。它提供:
     * 1. 所有内置类型的文本格式化功能
     * 2. 与basic_streambuf派生类通信实现实际输出
     */
    template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
    public:
        // 从basic_ios继承的类型定义
        typedef _CharT                     char_type;      // 字符类型
        typedef typename _Traits::int_type int_type;      // 整数类型
        typedef typename _Traits::pos_type pos_type;      // 位置类型
        typedef typename _Traits::off_type off_type;      // 偏移类型
        typedef _Traits                    traits_type;    // 特征类型

        // 非标准类型定义
        typedef basic_streambuf<_CharT, _Traits>     __streambuf_type;
        typedef basic_ios<_CharT, _Traits>           __ios_type;
        typedef basic_ostream<_CharT, _Traits>       __ostream_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> > 
                                                     __num_put_type;
        typedef ctype<_CharT>                        __ctype_type;
        /**
         * @brief 基础构造函数
         * @param __sb 指向stream buffer的指针
         *
         * 这个构造函数很少被用户直接调用
         * 通常由派生类的初始化列表调用，传入它们自己的stream buffer指针
         */
        explicit
        basic_ostream(__streambuf_type* __sb) {
            this->init(__sb);
        }

        /**
         * @brief 基础析构函数
         * 
         * 除了提供一个虚析构函数外，几乎不做任何事情
         */
        virtual
        ~basic_ostream() { }

        /// 用于安全前缀/后缀操作的类
        class sentry;
        friend class sentry;

        /**
         * @brief 操纵器接口
         *
         * 用于支持如std::endl和std::hex这样的操纵器
         * 这些函数在"std::cout << std::endl"这样的结构中使用
         * 更多信息请参见iomanip头文件
         */
        __ostream_type&
        operator<<(__ostream_type& (*__pf)(__ostream_type&)) {
            return __pf(*this);
        }

        __ostream_type&
        operator<<(__ios_type& (*__pf)(__ios_type&)) {
            __pf(*this);
            return *this;
        }

        __ostream_type&
        operator<<(ios_base& (*__pf) (ios_base&)) {
            __pf(*this);
            return *this;
        }
        /**
         * @name 插入器
         * 所有operator<<函数(即格式化输出函数)都有一些共同行为：
         * 1. 首先构造一个std::basic_ostream::sentry类型的临时对象
         * 2. 如果sentry状态良好，则尝试生成适合参数类型的数据
         * 3. 如果在插入过程中抛出异常，ios_base::badbit会被设置
         *    但不会导致抛出ios_base::failure异常
         */

        /**
         * @brief 整数类型插入器
         * @param __n 内置整数类型变量
         * @return 如果成功则返回*this
         *
         * 这些函数使用流的当前locale(特别是num_get facet)来执行数值格式化
         */
        __ostream_type&
        operator<<(long __n) {
            return _M_insert(__n);
        }

        __ostream_type&
        operator<<(unsigned long __n) {
            return _M_insert(__n);
        }

        __ostream_type&
        operator<<(bool __n) {
            return _M_insert(__n);
        }

        __ostream_type&
        operator<<(short __n);

        __ostream_type&
        operator<<(unsigned short __n) {
            return _M_insert(static_cast<unsigned long>(__n));
        }

        __ostream_type&
        operator<<(int __n);

        __ostream_type&
        operator<<(unsigned int __n) {
            return _M_insert(static_cast<unsigned long>(__n));
        }

#ifdef _GLIBCXX_USE_LONG_LONG
        __ostream_type&
        operator<<(long long __n) {
            return _M_insert(__n);
        }

        __ostream_type&
        operator<<(unsigned long long __n) {
            return _M_insert(__n);
        }
#endif
        /**
         * @brief 浮点数类型插入器
         * @param __f 内置浮点类型变量
         * @return 如果成功则返回*this
         *
         * 这些函数使用流的当前locale(特别是num_get facet)来执行数值格式化
         */
        __ostream_type&
        operator<<(double __f) {
            return _M_insert(__f);
        }

        __ostream_type&
        operator<<(float __f) {
            return _M_insert(static_cast<double>(__f));
        }

        __ostream_type&
        operator<<(long double __f) {
            return _M_insert(__f);
        }

        /**
         * @brief 指针类型插入器
         * @param __p 指针类型变量
         * @return 如果成功则返回*this
         *
         * 这些函数使用流的当前locale(特别是num_get facet)来执行数值格式化
         */
        __ostream_type&
        operator<<(const void* __p) {
            return _M_insert(__p);
        }

#if __cplusplus >= 201703L
        /**
         * @brief nullptr插入器
         * 将nullptr转换为字符串"nullptr"输出
         */
        __ostream_type&
        operator<<(nullptr_t) {
            return *this << "nullptr";
        }
#endif

        /**
         * @brief 从另一个streambuf提取数据
         * @param __sb 指向streambuf的指针
         *
         * 这个函数的行为类似于基本算术提取器：
         * 1. 构造一个sentry对象
         * 2. 具有相同的错误处理行为
         * 
         * 如果__sb为NULL，流将在其错误状态中设置failbit
         */
        __ostream_type&
        operator<<(__streambuf_type* __sb);
        /**
         * @name 未格式化输出函数
         *
         * 所有未格式化输出函数都有一些共同行为：
         * 1. 首先构造一个std::basic_ostream::sentry类型的临时对象
         * 2. 如果sentry状态良好，则尝试生成适合参数类型的数据
         * 3. 如果在插入过程中抛出异常，ios_base::badbit会被设置
         *    如果badbit在流的异常掩码中，异常将被重新抛出
         */

        /**
         * @brief 简单插入函数
         * @param __c 要插入的字符
         * @return *this
         *
         * 尝试插入字符__c
         * 注意：此函数没有对signed char和unsigned char重载
         */
        __ostream_type&
        put(char_type __c);

        /**
         * @brief 核心写入功能，不使用sentry
         * @param __s 要插入的数组
         * @param __n 最大插入字符数
         */
        void
        _M_write(const char_type* __s, streamsize __n) {
            const streamsize __put = this->rdbuf()->sputn(__s, __n);
            if (__put != __n)
                this->setstate(ios_base::badbit);
        }

        /**
         * @brief 字符串插入
         * @param __s 要插入的数组
         * @param __n 最大插入字符数
         * @return *this
         *
         * 从__s复制字符并插入到流中，直到发生以下情况之一：
         * 1. 插入了__n个字符
         * 2. 向输出序列插入失败(这种情况下，badbit将被设置)
         *
         * 注意：此函数没有对signed char和unsigned char重载
         */
        __ostream_type&
        write(const char_type* __s, streamsize __n);
        /**
         * @brief 刷新关联的输出序列
         * @return *this
         *
         * 如果rdbuf()不为NULL，调用rdbuf()->pubsync()
         * 如果这个返回-1，设置badbit
         */
        __ostream_type&
        flush();

        /**
         * @brief 获取当前输出位置
         * @return 当前位置指示器，失败时返回pos_type(-1)
         */
        pos_type
        tellp();

        /**
         * @brief 设置输出位置
         * @param __pos 新的绝对位置
         * @return *this
         */
        __ostream_type&
        seekp(pos_type __pos);

        /**
         * @brief 相对移动输出位置
         * @param __off 相对偏移量
         * @param __dir 移动方向(参见ios_base::seekdir)
         * @return *this
         */
        __ostream_type&
        seekp(off_type __off, ios_base::seekdir __dir);

    protected:
        /**
         * @brief 基础构造函数
         * 
         * 这个构造函数不初始化任何成员，仅供派生类使用
         * 派生类必须调用init()来完成初始化
         */
        basic_ostream() { }

#if __cplusplus >= 201103L
        // 禁用移动构造和赋值
        basic_ostream(const basic_ostream&) = delete;
        basic_ostream& operator=(const basic_ostream&) = delete;

        // 移动构造和赋值
        basic_ostream(basic_ostream&& __rhs)
        : __ios_type() {
            __ios_type::move(__rhs);
        }

        basic_ostream& operator=(basic_ostream&& __rhs) {
            swap(__rhs);
            return *this;
        }

        void swap(basic_ostream& __rhs) {
            __ios_type::swap(__rhs);
        }
#endif
    private:
        /**
         * @brief 通用数值插入模板
         * @param __n 要插入的数值
         * @return *this
         *
         * 这是一个私有成员函数，用于实现所有数值插入操作符
         * 它使用num_put facet来格式化数值
         */
        template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __n);
    };

    /**
     * @brief 两个basic_ostream对象的交换
     * @param __x 第一个流
     * @param __y 第二个流
     *
     * 交换两个流的所有状态
     */
    template <typename _CharT, typename _Traits>
    inline void
    swap(basic_ostream<_CharT, _Traits>& __x,
         basic_ostream<_CharT, _Traits>& __y) {
        __x.swap(__y);
    }

    /**
     * @brief 标准字符流类型定义
     * 
     * - ostream 使用char
     * - wostream 使用wchar_t
     */
    typedef basic_ostream<char>    ostream;
    typedef basic_ostream<wchar_t> wostream;

} // namespace std
#endif /* _GLIBCXX_OSTREAM */
